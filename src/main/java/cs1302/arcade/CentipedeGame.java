package cs1302.arcade;

import java.util.Random;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import javafx.event.EventHandler;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.canvas.Canvas;
import javafx.geometry.Pos;
import java.util.ArrayList;
import java.util.List;
import javafx.animation.KeyFrame;
import javafx.event.ActionEvent;
import javafx.animation.Timeline;
import javafx.util.Duration;
import java.util.Random;
import java.util.Scanner;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.scene.control.Label;
import javafx.scene.control.MenuBar;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.MenuButton;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonType;

import javafx.stage.Modality;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;

import javafx.scene.control.TextInputDialog;
import javafx.stage.Stage;
import javafx.stage.Popup;

import cs1302.arcade.ArcadeApp;
import cs1302.arcade.CentipedePiece;
import cs1302.arcade.CentipedeSquare;
import cs1302.arcade.CentipedeScorpion;
import cs1302.arcade.CentipedeSpider;
import cs1302.arcade.CentipedePoint;
import java.util.stream.Collectors;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Map;
import java.io.PrintWriter;
import java.io.File;
import java.io.IOException;

/**
 * Represents a Centipede game.
 */
public class CentipedeGame extends VBox {
    Text highScoreText;
    KeyFrame keyFrame;
    TextField initialInputField;
    Timeline timeline;
    Random rng;
    Group g;
    Pane pane;
    GridPane gp;
    ArrayList<CentipedePiece> centipede;
    ArrayList<CentipedePoint> fleas;
    CentipedeSquare[][] board;
    ArrayList<CentipedePoint> bullets;
    ArrayList<CentipedeScorpion> scorpions;
    ArrayList<CentipedeMushroom> mushrooms;
    ArrayList<CentipedeSpider> spiders;
    int score;
    CentipedePoint ship;
    int spawnTime;
    int movementSpeed;
    int scorpionCounter;
    ArcadeApp app;
    int lives;
    int difficulty;
    Timeline tl1;
    Timeline tl2;
    KeyFrame kf1;
    KeyFrame kf2;

    /** Menu Bar Items. */
    HBox menu;
    Label scoreLabel;
    Label livesLabel;
    Label difficultyLabel;
    Button highScoresButton;
    Button restartButton;
    Button exitButton;
    Button gameSelectButton;

    /** High Score Items. */
    Popup popup;
    LinkedHashMap<String, Integer> highScores;

    /**
     * Return a key event handler that moves to the rectangle to the left
     * or the right depending on what key event is generated by the associated
     * node.
     * @return the key event handler
     */
    public EventHandler<? super KeyEvent> createKeyHandler() {
        return event -> {
            switch (event.getCode()) {
            case LEFT:  // KeyCode.LEFT
                if (ship.getX() > 0) {
                    moveShip(-1);
                }
                break;
            case RIGHT: // KeyCode.RIGHT
                if (ship.getX() < 19) {
                    moveShip(1);
                }
                break;
            case UP:
                if (ship.getY() > 16) {
                    moveShipVertical(-1);
                }
                break;
            case SPACE:
                if (bullets.size() < 5 && !board[ship.getY() - 1][ship.getX()].getIsBullet()) {
                    shoot();
                }
                break;
            case DOWN:
                if (ship.getY() <= 19) {
                    moveShipVertical(1);
                }
                break;
            case Z:
                if (bullets.size() < 5 && !board[ship.getY() - 1][ship.getX()].getIsBullet()) {
                    shoot();
                }
                break;
            default:
                // do nothing
            } // switch
            // TODO bounds checking
        };
    } // createKeyHandler

    /**
     * Responsible for basic board setup.
     */
    public void setupBoard() {
        board = new CentipedeSquare[20][20];
        gp = new GridPane();

        createGameOverPopup();

        for (int i = 0; i < 20; i++) {
            for (int j = 0; j < 20; j++) {
                board[i][j] = new CentipedeSquare();
                board[i][j].setAlignment(Pos.CENTER);
                GridPane.setRowIndex(board[i][j], i);
                GridPane.setColumnIndex(board[i][j], j);
                gp.getChildren().add(board[i][j]);
            }
        }

        gp.setGridLinesVisible(true);

        // Initialize lists
        bullets = new ArrayList<CentipedePoint>();
        fleas = new ArrayList<CentipedePoint>();
        scorpions = new ArrayList<CentipedeScorpion>();
        mushrooms = new ArrayList<CentipedeMushroom>();
        spiders = new ArrayList<CentipedeSpider>();
        centipede = new ArrayList<CentipedePiece>();
        rng = new Random();

        // Set ship at bottom middle
        board[19][10].setShip();
        ship = new CentipedePoint(10, 19);

        // Misc game vars
        scorpionCounter = 0;
        difficulty = 1;
        lives = 3;

        // Initialize centipede
        addCentipede();

    }

    /**
     * Responsible for basic menu setup.
     */
    public void setupMenu() {
        menu = new HBox(5);

        exitButton = new Button("Exit");
        restartButton = new Button("Restart");
        highScoresButton = new Button("High Scores");
        gameSelectButton = new Button("Game Select");
        scoreLabel = new Label("Score " + score);
        difficultyLabel = new Label("Level " + difficulty);
        livesLabel = new Label("Lives " + lives);

        EventHandler<? super MouseEvent> exitHandler = e -> {
            System.exit(0);
        };
        exitButton.setOnMouseClicked(exitHandler);

        EventHandler<? super MouseEvent> gameSelectHandler = e -> {
            app.setMainScene();
        };
        gameSelectButton.setOnMouseClicked(gameSelectHandler);

        EventHandler<? super MouseEvent> resetHandler = r -> {
            app.setCentipedeScene();
        };
        restartButton.setOnMouseClicked(resetHandler);

        EventHandler<? super MouseEvent> highScoresHandler = h -> {
            highScoreDisplay();
        };
        highScoresButton.setOnMouseClicked(highScoresHandler);

        menu.getChildren().addAll(exitButton, restartButton, gameSelectButton, highScoresButton,
                                  scoreLabel, difficultyLabel, livesLabel);
    }

    /**
     * Updates the menu to reflect current score, difficulty, and lives.
     */
    private void updateMenu() {
        scoreLabel.setText("Score " + score);
        difficultyLabel.setText("Level " + difficulty);
        livesLabel.setText("Lives " + lives);
    }

    /**
     * Creates a game of Centipede.
     * @param app the running instance of ArcadeApp.
     */
    public CentipedeGame(ArcadeApp app) {
        this.app = app;

        // Main setup
        setupMenu();
        setupBoard();
        this.getChildren().add(menu);
        this.getChildren().addAll(gp);

        setupTimeline1();

        /* This EventHandler is responsible for adding enemy objects
         * to the game.
         */
        EventHandler<ActionEvent> addObjHandler = event -> {
            // Add scorpions on a delay
            scorpionCounter++;
            if (scorpionCounter % 2 == 0) {
                addFlea();
            }
            if (scorpionCounter % 7 == 0) {
                addScorpion();
            }

            // Alternate adding spiders to the right and left
            if (scorpionCounter % 5 == 0) {
                if (spiders.size() % 2 == 0) {
                    addSpiderLeft();
                } else {
                    addSpiderRight();
                }
            }
        };

        spawnTime = 4000;
        kf1 = new KeyFrame(Duration.millis(spawnTime), addObjHandler);
        tl1 = new Timeline();
        tl1.setCycleCount(Timeline.INDEFINITE);
        tl1.getKeyFrames().add(kf1);
        tl1.play();
    }

    /**
     * Sets up the timeline responsible for checking bullet collisions.
     */
    private void setupTimeline1() {
        /* Movement speed serves as the difficult adjustment.
         * It increases depending on score making
         * everything, including bullets speed up.
         */
        movementSpeed = 400;
        EventHandler<ActionEvent> updateBoardHandler = event -> {
            checkBulletCollision();
            checkFleaCollision();
            checkScorpionCollision();
            checkCentipedeCollision();

            updateMenu();
            checkGameOver();

            // Adjust difficulty
            if (score >= 10000) {
                difficulty = 2;
                movementSpeed = 200;
            } else if (score >= 20000) {
                difficulty = 3;
                movementSpeed = 100;
            }
            updateBoard();
        };
        kf2 = new KeyFrame(Duration.millis(500), updateBoardHandler);
        tl2 = new Timeline();
        tl2.setCycleCount(Timeline.INDEFINITE);
        tl2.getKeyFrames().add(kf2);
        tl2.play();

    }

    /**
     * Adds a centipede to the board.
     */
    private void addCentipede() {
        // Add scorpion with 10 pieces
        for (int i = 0; i < 10; i++) {
            centipede.add(new CentipedePiece(i, 3, false, true));
            board[3][i].setBlank();
            board[3][i].setCentipede();
        }
    }

    /**
     * Provides horizontal ship movement.
     * @param offset the amount to move the ship.  Negative is left,
     * positive is right.
     */
    private void moveShip(int offset) {
        board[ship.getY()][ship.getX()].setBlank();
        board[ship.getY()][ship.getX() + offset].setShip();
        ship.setX(ship.getX() + offset);
    }

    /**
     * Provides vertical ship movement.
     * @param offset the amount to move the ship.  Negative is left,
     * positive is right.
     */
    private void moveShipVertical(int offset) {
        board[ship.getY()][ship.getX()].setBlank();
        board[ship.getY() + offset][ship.getX()].setShip();
        ship.setY(ship.getY() + offset);
    }

    /**
     * Adds a flea to a random space on the top of the board.
     */
    private void addFlea() {
        int randomX = rng.nextInt((19 - 0) + 1) + 0;

        board[0][randomX].setFlea();
        fleas.add(new CentipedePoint(randomX, 0));

    }

    /**
     * Adds a scorpion to the top left corner of the board.
     */
    private void addScorpion() {
        // Start in top left corner and go right
        CentipedeScorpion s = new CentipedeScorpion(0, 0, false);
        board[s.getY()][s.getX()].setScorpion();
        scorpions.add(s);
    }

    /**
     * Adds a spider to the right side of the board.
     */
    private void addSpiderRight() {
        // Start in top right corner and zig zag
        int randomY = rng.nextInt((7 - 0) + 1);
        CentipedeSpider s = new CentipedeSpider(19, randomY, true, true);
        board[s.getY()][s.getX()].setSpider();
        spiders.add(s);
    }

    /**
     * Adds a spider to the right side of the board.
     */
    private void addSpiderLeft() {
        // Start in top right corner and zig zag
        int randomY = rng.nextInt((7 - 0) + 1);
        CentipedeSpider s = new CentipedeSpider(0, randomY, false, true);
        board[s.getY()][s.getX()].setSpider();
        spiders.add(s);
    }

    /**
     * Creates a bullet above the ship.
     */
    private void shoot() {
        // Add a bullet to the ship's location but up one square
        CentipedePoint bullet = new CentipedePoint(ship.getX(), ship.getY() - 1);
        board[bullet.getY()][bullet.getX()].setBullet();
        bullets.add(bullet);

    }

    /**
     * Checks for the bullet colliding with any other object on the board.
     */
    private void checkBulletCollision() {
        // Remove if it's going to hit the wall
        for (CentipedePoint bullet : bullets) {
            if (bullet.getY() - 1 < 0) {
                board[bullet.getY()][bullet.getX()].setBlank();
                bullets.remove(bullet);
            } else if (!board[bullet.getY() - 1][bullet.getX()].getIsBlank()) {
                checkBulletObjectCollisions(bullet);
                
                // Remove bullet from list and board
                board[bullet.getY() - 1][bullet.getX()].setBlank();
                board[bullet.getY()][bullet.getX()].setBlank();
                bullets.remove(bullet);
            }
        }
    }

    /**
     * Checks to see if the bullet collides with any enemy object.
     * @param bullet the bullet to be checked against all enemy objects.
     */
    private void checkBulletObjectCollisions(CentipedePoint bullet) {
        // Check fleas to see if they are going to intersect the bullet
        for (CentipedePoint flea : fleas) {
            if (flea.getX() == bullet.getX() && flea.getY() == bullet.getY() - 1) {
                score += 200;
                fleas.remove(flea);
            }
        }

        // Check mushroom
        for (CentipedeMushroom mushroom : mushrooms) {
            if (mushroom.getX() == bullet.getX() && mushroom.getY() == bullet.getY() - 1) {
                mushroom.reduceHealth();
                if (mushroom.getHealth() <= 0) {
                    mushrooms.remove(mushroom);
                    board[mushroom.getY()][mushroom.getX()].setBlank();
                } else {
                    board[mushroom.getY()][mushroom.getX()].setDamagedMushroom();
                }
            }
        }

        // Check scorpions
        for (CentipedeScorpion scorpion : scorpions) {
            if (scorpion.getX() == bullet.getX() && scorpion.getY() == bullet.getY() - 1) {
                board[scorpion.getY()][scorpion.getX()].setBlank();
                scorpions.remove(scorpion);
                score += 2000;
            }
        }

        // Check spiders
        for (CentipedeSpider spider : spiders) {
            if (spider.getX() == bullet.getX() && spider.getY() == bullet.getY() - 1) {
                board[spider.getY()][spider.getX()].setBlank();
                if (spider.getY() >= 15) {
                    score += 900;
                } else if (spider.getY() >= 10) {
                    score += 600;
                } else {
                    score += 300;
                }
                spiders.remove(spider);
            }
        }

        // Check centipede
        for (CentipedePiece c : centipede) {
            if (c.getX() == bullet.getX() && c.getY() == bullet.getY() - 1) {
                board[c.getY()][c.getX()].setDeadCentipede();
                score += 100;
                c.setDead(true);
            }
        }
    }

    /**
     * Checks for flea's colliding with other objects on the board.
     */
    private void checkFleaCollision() {
        for (CentipedePoint flea : fleas) {
            if (flea.getY() + 1 > 19) {
                board[flea.getY()][flea.getX()].setBlank();
                fleas.remove(flea);
            } else if (board[flea.getY() + 1][flea.getX()].getIsShip()) {
                lives--;
                board[flea.getY() + 1][flea.getX()].setBlank();
            }
        }
    }

    /**
     * Checks for scorpion's colliding with other objects on the board.
     */
    private void checkScorpionCollision() {
        for (CentipedeScorpion scorpion : scorpions) {
            if (scorpion.getX() == 19 && scorpion.getY() == 0) {
                board[scorpion.getY()][scorpion.getX()].setBlank();

                return;
            }

            if (scorpion.getX() == ship.getX() && scorpion.getY() == ship.getY()) {
                lives--;
            }

        }
    }

    /**
     * Checks for spiders colliding with other objects on the board.
     */
    private void checkSpiderCollision() {
        for (CentipedeSpider spider : spiders) {
            if (spider.getY() == ship.getY() && spider.getX() == ship.getX()) {
                lives--;
            }
        }
    }

    /**
     * Checks for centipede parts colliding with other objects on the board.
     */
    private void checkCentipedeCollision() {
        if (checkDeadCentipede()) {
            addCentipede();
        }

        for (CentipedePiece c : centipede) {
            if (c.getX() == ship.getX() && c.getY() == ship.getY()) {
                lives--;
            }
        }

    }

    /**
     * Checks to see if all pieces of the centipede are dead.
     * @return true if the centipede is all dead
     */
    private boolean checkDeadCentipede() {
        for (CentipedePiece c : centipede) {
            if (!c.getDead()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Coordinates the movement of the pieces on the board.
     */
    private void updateBoard() {
        // Increment bullets up
        for (CentipedePoint bullet : bullets) {
            board[bullet.getY()][bullet.getX()].setBlank();
            board[bullet.getY() - 1][bullet.getX()].setBullet();
            bullet.setY(bullet.getY() - 1);
        }

        // Update spiders
        for (CentipedeSpider spider : spiders) {
            updateSpiderWest(spider);
            updateSpiderEast(spider);
            
        }

        // Update centipede depending on if the head has reached the top left or bottom left
        // and needs to go the other way.
        CentipedePiece head = centipede.get(centipede.size() - 1);
        if (head.getY() == 19 && head.getX() == 0 && head.getSouth() && head.getWest()) {
            head.setSouth(false);
        } else if (head.getY() == 0 && head.getX() == 0 && !head.getSouth() && head.getWest()) {
            head.setSouth(true);
        } else if (head.getY() == 19 && head.getX() == 19 && head.getSouth() && !head.getWest()) {
            head.setSouth(false);
        } else if (head.getY() == 0 && head.getX() == 19 && !head.getSouth() && !head.getWest()) {
            head.setSouth(true);
        }   

        // Appropriate head direction up or down
        if (head.getSouth()) {
            updateCentipedeSouth();
        } else {
            updateCentipedeNorth();
        }

        // Update fleas
        updateFleas();

        // Update scorpions
        updateScorpions();
    }

    /**
     * Updates each flea's board position.
     */
    private void updateFleas() {
        // Fleas go down and COULD leave a mushroom
        for (CentipedePoint flea : fleas) {
            board[flea.getY()][flea.getX()].setBlank();
            flea.setY(flea.getY() + 1);

            // Don't increment flea it it's about to hit something
            if (board[flea.getY()][flea.getX()].getIsBlank()
                || board[flea.getY()][flea.getX()].getIsMushroom()) {
                board[flea.getY()][flea.getX()].setFlea();
            } else if (board[flea.getY() + 1][flea.getX()].getIsCentipede()) {
                flea.setY(flea.getY() + 2);
                board[flea.getY()][flea.getX()].setFlea();
            } else {
                flea.setY(flea.getY() + 2);
                board[flea.getY()][flea.getX()].setFlea();
            }
            int random = rng.nextInt(19 - 0) + 1;
            if (random <= 2) {
                board[flea.getY() - 1][flea.getX()].setMushroom();
                mushrooms.add(new CentipedeMushroom(flea.getX(), flea.getY() - 1));
            }
        }
    }

    /**
     * Updates each scorpion's board position.
     */
    private void updateScorpions() {
        for (CentipedeScorpion s : scorpions) {
            board[s.getY()][s.getX()].setBlank();

            if (s.getX() == 18 && !s.getWest() && board[s.getY()][19].getIsMushroom()) {
                // If mushroom is on the edge, skip down and turn it mushroom
                s.setY(s.getY() + 1);
                s.setX(19);
                s.setWest(true);
                board[s.getY()][s.getX()].setScorpion();
                board[s.getY() - 1][s.getX()].setPoisonMushroom();
            } else if (s.getX() == 1 && s.getWest() && board[s.getY()][0].getIsMushroom()) {
                // If mushroom is on the edge, skip down and turn it mushroom
                s.setY(s.getY() + 1);
                s.setX(0);
                s.setWest(false);
                board[s.getY()][s.getX()].setScorpion();
                board[s.getY() - 1][s.getX()].setPoisonMushroom();
            } else if (s.getX() == 19 && !s.getWest()) {
                s.setY(s.getY() + 1);
                s.setWest(true);
                board[s.getY()][s.getX()].setScorpion();
            } else if (s.getX() == 0 && s.getWest()) {
                s.setY(s.getY() + 1);
                s.setWest(false);
                board[s.getY()][s.getX()].setScorpion();
            } else {
                if (s.getWest()) {
                    if (board[s.getY()][s.getX() - 1].getIsMushroom()) {
                        board[s.getY()][s.getX() - 1].setPoisonMushroom();
                        s.setX(s.getX() - 2);
                        board[s.getY()][s.getX()].setScorpion();
                    } else {
                        s.setX(s.getX() - 1);
                        board[s.getY()][s.getX()].setScorpion();
                    }
                } else {
                    if (board[s.getY()][s.getX() + 1].getIsMushroom()) {
                        board[s.getY()][s.getX() + 1].setPoisonMushroom();
                        s.setX(s.getX() + 2);
                        board[s.getY()][s.getX()].setScorpion();
                    } else {
                        s.setX(s.getX() + 1);
                        board[s.getY()][s.getX()].setScorpion();
                    }

                }
            }
        }
    }

    /**
     * Updates the centipede if it is moving south.
     */
    private void updateCentipedeSouth() {
        for (int i = centipede.size() - 1; i >= 0; i--) {
            CentipedePiece head = centipede.get(i);

            // Check to make sure the head has room to move.
            // Then increment each piece into the next spot.
            if (!head.getWest() && head.getX() == 19) {
                head.setY(head.getY() + 1);
                head.setWest(true);
                board[head.getPrevY()][head.getX()].setBlank();
            } else if (head.getWest() && head.getX() == 0) {
                head.setY(head.getY() + 1);
                head.setWest(false);
                board[head.getPrevY()][head.getX()].setBlank();
            } else if (head.getWest() && board[head.getY()][head.getX() - 1].getIsMushroom()) {
                head.setY(head.getY() + 1);
                head.setWest(false);
                board[head.getPrevY()][head.getX()].setBlank();
            } else if (!head.getWest() && board[head.getY()][head.getX() + 1].getIsMushroom()) {
                head.setY(head.getY() + 1);
                head.setWest(true);
                board[head.getPrevY()][head.getX()].setBlank();
            } else {
                if (head.getWest()) {
                    head.setX(head.getX() - 1);
                } else {
                    head.setX(head.getX() + 1);
                }
                board[head.getY()][head.getPrevX()].setBlank();
            }

            // Check for a dead centipede head and set appropriately
            if (head.getDead()) {
                board[head.getY()][head.getX()].setDeadCentipede();
            } else {
                board[head.getY()][head.getX()].setCentipede();
            }
        }
    }

    /**
     * Updates the centipede if it is moving north.
     */
    private void updateCentipedeNorth() {
        for (int i = centipede.size() - 1; i >= 0; i--) {
            CentipedePiece head = centipede.get(i);

            // Check to make sure the head has room to move.
            // Then increment each piece into the next spot.
            if (!head.getWest() && head.getX() == 19) {
                head.setY(head.getY() - 1);
                head.setWest(true);
                board[head.getPrevY()][head.getX()].setBlank();
            } else if (head.getWest() && head.getX() == 0) {
                head.setY(head.getY() - 1);
                head.setWest(false);
                board[head.getPrevY()][head.getX()].setBlank();
            } else if (head.getWest() && board[head.getY()][head.getX() - 1].getIsMushroom()) {
                head.setY(head.getY() - 1);
                head.setWest(false);
                board[head.getPrevY()][head.getX()].setBlank();
            } else if (!head.getWest() && board[head.getY()][head.getX() + 1].getIsMushroom()) {
                head.setY(head.getY() - 1);
                head.setWest(true);
                board[head.getPrevY()][head.getX()].setBlank();
            } else {
                if (head.getWest()) {
                    head.setX(head.getX() - 1);
                } else {
                    head.setX(head.getX() + 1);
                }
                board[head.getY()][head.getPrevX()].setBlank();
            }

            // Check for a dead centipede head and set appropriately
            if (head.getDead()) {
                board[head.getY()][head.getX()].setDeadCentipede();
            } else {
                board[head.getY()][head.getX()].setCentipede();
            }
        }
    }

    /**
     * Updates each spider's position on the board going east.
     * @param spider the spider to be updated.
     */
    private void updateSpiderEast(CentipedeSpider spider) {
        int newX = spider.getX();
        int newY = spider.getY();

        // Spiders going east and south
        if (!spider.getWest() && spider.getSouth()) {
            if (spider.getY() == 19 && spider.getX() != 19) {
                newY--;
                newX++;
                spider.setSouth(false);
            } else if (spider.getY() != 19 && spider.getX() == 19) {
                newY++;
                newX--;
            } else if (spider.getY() == 19 && spider.getX() == 19) {
                newY--;
                newX--;
                spider.setSouth(false);
                spider.setWest(false);
            } else {
                newY++;
                newX++;
            }
        }

        // Spiders going east and north
        if (!spider.getWest() && !spider.getSouth()) {
            if (spider.getY() == 0 && spider.getX() != 19) {
                newY++;
                newX++;
                spider.setSouth(true);
            } else if (spider.getY() != 0 && spider.getX() == 19) {
                newY--;
                newX--;
                spider.setWest(true);
            } else if (spider.getY() == 0 && spider.getX() == 19) {
                newY++;
                newX--;
                spider.setWest(true);
                spider.setSouth(true);
            } else {
                newY--;
                newX++;
            }
        }

        // Prevent centipede collisions
        if (board[newY][newX].getIsCentipede()) {
            if (spider.getSouth()) {
                newY++;
            } else {
                newY--;
            }
        }

        board[newY][newX].setSpider();
        board[spider.getY()][spider.getX()].setBlank();
        spider.setX(newX);
        spider.setY(newY);
    }

    /**
     * Updates each spider's position on the board going west.
     * @param spider the spider to be updated.
     */
    private void updateSpiderWest(CentipedeSpider spider) {
        int newX = spider.getX() ;
        int newY = spider.getY();
        // Spiders going west and south
        if (spider.getWest() && spider.getSouth()) {
            if (spider.getY() == 19 && spider.getX() != 0) {
                newX--;
                newY--;
                spider.setSouth(false);
            } else if (spider.getY() != 19 && spider.getX() == 0) {
                newX++;
                newY++;
                spider.setWest(false);
            } else if (spider.getY() == 19 && spider.getX() == 0) {
                newX++;
                newY--;
                spider.setWest(false);
                spider.setSouth(false);
            } else {
                newY++;
                newX--;
            }
        }

        // Spiders going west and north
        if (spider.getWest() && !spider.getSouth()) {
            if (spider.getY() == 0 && spider.getX() != 0) {
                newX--;
                newY++;
                spider.setSouth(true);
            } else if (spider.getY() != 0 && spider.getX() == 0) {
                newY--;
                newX++;
                spider.setWest(false);
            } else if (spider.getY() == 0 && spider.getX() == 0) {
                newY++;
                newX++;
                spider.setSouth(true);
                spider.setWest(false);
            } else {
                newY--;
                newX--;
            }
        }

        // Prevent centipede collisions
        if (board[newY][newX].getIsCentipede()) {
            if (spider.getSouth()) {
                newY++;
            } else {
                newY--;
            }
        }

        board[newY][newX].setSpider();
        board[spider.getY()][spider.getX()].setBlank();
        spider.setX(newX);
        spider.setY(newY);
    }


    /**
     * Creates the game over popup.
     */
    private void createGameOverPopup() {
        // pbox will hold components including the high score list
        popup = new Popup();
        VBox pbox = new VBox(5);

        Label gameOverLabel = new Label("Game Over");
        pbox.getChildren().add(gameOverLabel);


        // Set buttons for Restart, Game Select, and Back
        Button btnRestart = new Button("Restart");
        EventHandler<? super MouseEvent> restartHandler = r -> {
            popup.hide();
            app.setCentipedeScene();
        };
        btnRestart.setOnMouseClicked(restartHandler);

        Button btnSelect = new Button("Game Select");
        EventHandler<? super MouseEvent> selectHandler = d -> {
            popup.hide();
            app.setMainScene();
        };
        btnSelect.setOnMouseClicked(selectHandler);

        Button btnExit = new Button("Exit");
        EventHandler<? super MouseEvent> exitHandler = e -> {
            popup.hide();
            System.exit(0);
        };
        btnExit.setOnMouseClicked(exitHandler);

        HBox buttonBox = new HBox(5);
        buttonBox.getChildren().addAll(btnRestart, btnSelect, btnExit);
        pbox.getChildren().addAll(buttonBox);

        // Add score box
        Label initialInstructions = new Label("Enter your initials (no commas)!");
        initialInputField = new TextField("Initials");
        Button input = new Button("Enter");

        pbox.getChildren().addAll(initialInstructions, initialInputField, input);
        EventHandler<? super MouseEvent> highScoreHandler = h -> {
            String text = initialInputField.getText();
            if (text == null || text.isEmpty() || text.contains(",")) {
                return;
            } else {
                addHighScores(initialInputField.getText());
                input.setDisable(true);
            }
        };
        input.setOnMouseClicked(highScoreHandler);

        // Calculate high score and add to table
        readHighScores();

        popup.getContent().add(pbox);

    }

    /**
     * Displays the high score alert.
     */
    private void highScoreDisplay() {
        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("High Scores");
        alert.setHeaderText(null);

        String s = "";

        readHighScores();
        Map<String, Integer> sorted = sortHighScores();

        for (String key : sorted.keySet()) {
            s += key.replaceAll("\\s+", "") + ": " + sorted.get(key) + "\n";

        }

        alert.setContentText(s);
        alert.showAndWait();
    }

    /**
     * Adds high scores to the list should they qualify.
     * @param newEntry the user's text from the input box.
     */
    private void addHighScores(String newEntry) {
        for (String key : highScores.keySet()) {
            if (key.equals(newEntry)) {
                newEntry += "\t\t";
            }
        }
        highScores.put(newEntry, score);
        Map<String, Integer> sorted = sortHighScores();

        writeHighScores(sorted);
    }

    /**
     * Writes high scores to the score file from the hash map.
     * @param scores a map containing name - score key values.
     */
    private void writeHighScores(Map<String, Integer> scores) {
        String s = "";
        int n = 0;
        // Only write the top 5 high scores
        for (String key : scores.keySet()) {
            if (n < 5) {
                s += key.replaceAll("\\s+", "") + "," + scores.get(key) + "\n";
            }
            n++;
        }

        try {
            File f = new File("centipede_scores.txt");
            PrintWriter w = new PrintWriter(f);
            w.print(s);
            w.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Reads high scores into a hash map from the score file.
     */
    private void readHighScores() {
        try {
            
            File f = new File("centipede_scores.txt");
            if (!f.exists()) {
                f.createNewFile();
            }

            Scanner s = new Scanner(f);
            highScores = new LinkedHashMap<>();

            while (s.hasNext()) {
                String line = s.next();
                String[] values = line.split(",");
                highScores.put(values[0], Integer.parseInt(values[1]));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Sorts high scores descending according to their value.
     * @return a map with the user's name and score in descending order.
     */
    private Map<String, Integer> sortHighScores() {
        Map<String, Integer> result = highScores.entrySet().stream()
            .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,
                (oldValue, newValue) -> oldValue, LinkedHashMap::new));

        return result;
    }

    /**
     * Checks to see if the user is out of lives.  Creates and calls
     * the game over popup if so.
     */
    private void checkGameOver() {
        if (lives == 0) {
            tl1.pause();
            tl2.pause();
            sortHighScores();
            popup.show(app.stage);
        }

    }


}
